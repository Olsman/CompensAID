% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UpdateMatrixInfo.R
\name{UpdateMatrixInfo}
\alias{UpdateMatrixInfo}
\title{Calculate segment information}
\usage{
UpdateMatrixInfo(
  si.input,
  range.input = NULL,
  primary,
  secondary,
  output,
  rv.input,
  segment = NULL,
  population = NULL
)
}
\arguments{
\item{si.input}{(dataFrame): dataFrame containing SSI info.}

\item{range.input}{(numerical): Width of each segment.}

\item{primary}{(character): Name of the primary marker.}

\item{secondary}{(character) Name of the secondary marker.}

\item{output}{(character): Will be "PASS" or "No positive/negative population" depending on the required events.}

\item{rv.input}{(numerical): Number of segments.}

\item{segment}{(numerical): The specific segment for which the information is updated.}

\item{population}{(matrix): Matrix with the population for which the information is obtained.}
}
\value{
(dataFrame) Returns a dataframe with an update SSI information dataFrame.
}
\description{
Calculate segment information
}
\examples{
# Import FCS file
file <- flowCore::read.FCS(system.file("extdata", "68983.fcs", package = "compensAID"))

# Marker names
primary.marker <- "CD19"
secondary.marker <- "CD3"

# Channel names
cp <- "PE-Cy5-A"
cs <- "PE-Cy7-A"

# Density-based cut-off detection
center.plot <- 2
co <- DensityGating(og = file,
                    cp.value = center.plot)

# Get combinations
mc <- GetMarkerCombinations(og = file)

# Parameter for the distance between the primary positive and negative population
separation.distance <- 0.25

# Obtain empty SSI matrix information
range.value <- 4
si <- EmptyMatrixInfo(og = file,
                      rv.input = range.value,
                      mc.input = mc,
                      co.input = co,
                      sd.input = separation.distance)

# Obtain populations
pop <- GetPopulations(og = file,
                      primary = primary.marker,
                      secondary = secondary.marker,
                      co.input = co,
                      sd.input = separation.distance)

# Select primary positive population
population.positive <- pop$primary.positive

# Get the events that fall within the fourth segment
segment.value <- 4
range.value <- (max(population.positive[, cp]) - min(population.positive[, cp]))/segment.value

# Adjust the SSI info if there are >20 events in the (segmented) positive population
# (output = "PASS"); meaning more events present than threshold
si <- UpdateMatrixInfo(si.input = si,
                       rv.input = segment.value,
                       range.input = range.value,
                       primary = primary.marker,
                       secondary = secondary.marker,
                       output = "PASS",
                       population = pop)

}
\seealso{
\code{\link{CompensAID}}, \code{\link{DensityGating}}, \code{\link{EmptyMatrixInfo}}, \code{\link{GetPopulations}}
}
